//å°†ä¸€ä¸ªæŒ‰ç…§å‡åºæ’åˆ—çš„æœ‰åºæ•°ç»„ï¼Œè½¬æ¢ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚ 
//
// æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ã€‚ 
//
// ç¤ºä¾‹: 
//
// ç»™å®šæœ‰åºæ•°ç»„: [-10,-3,0,5,9],
//
//ä¸€ä¸ªå¯èƒ½çš„ç­”æ¡ˆæ˜¯ï¼š[0,-3,9,-10,null,5]ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä¸‹é¢è¿™ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼š
//
//      0
//     / \
//   -3   9
//   /   /
// -10  5
// 
// Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ 
// ğŸ‘ 655 ğŸ‘ 0

package com.glj.leetcode.editor.cn;

public class ConvertSortedArrayToBinarySearchTree{
    public static void main(String[] args) {
        Solution solution = new ConvertSortedArrayToBinarySearchTree().new Solution();
    }

    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    // æ³•ä¸€ï¼šä¸­åºéå†ï¼Œæ€»æ˜¯é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹
    // ç®—æ³•æ€æƒ³ï¼š(1)äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æ˜¯å‡åºåºåˆ—ï¼Œé¢˜ç›®ç»™å®šçš„æ•°ç»„æ˜¯æŒ‰ç…§å‡åºæ’åºçš„æœ‰åºæ•°ç»„ï¼Œå› æ­¤å¯ä»¥ç¡®ä¿æ•°ç»„æ˜¯äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†åºåˆ—ï¼›
    //         (2)ç»™å®šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ï¼Œä¸å¯ä»¥å”¯ä¸€åœ°ç¡®å®šäºŒå‰æœç´¢æ ‘ï¼›å¢åŠ ä¸€ä¸ªé™åˆ¶æ¡ä»¶ï¼šè¦æ±‚äºŒå‰æœç´¢æ ‘çš„é«˜åº¦å¹³è¡¡ï¼Œä¹Ÿä¸å¯ä»¥å”¯ä¸€ç¡®å®šï¼›
    //         (3)ç›´è§‚åœ°çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸­é—´æ•°å­—ä½œä¸ºäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿™æ ·åˆ†ç»™å·¦å³å­æ ‘çš„æ•°å­—ä¸ªæ•°ç›¸åŒæˆ–åªç›¸å·®1ï¼Œå¯ä»¥ä½¿å¾—æ ‘ä¿æŒå¹³è¡¡ï¼Œ
    //            å¦‚æœæ•°ç»„é•¿åº¦æ˜¯å¥‡æ•°ï¼Œåˆ™æ ¹èŠ‚ç‚¹çš„é€‰æ‹©æ˜¯å”¯ä¸€çš„ï¼Œå¦‚æœæ•°ç»„é•¿åº¦æ˜¯å¶æ•°ï¼Œåˆ™å¯ä»¥é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹æˆ–è€…é€‰æ‹©ä¸­é—´
    //            ä½ç½®å³è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé€‰æ‹©ä¸åŒçš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹åˆ™åˆ›å»ºçš„å¹³è¡¡äºŒå‰æœç´¢æ ‘ä¹Ÿæ˜¯ä¸åŒçš„ï¼›
    //         (4)ç¡®å®šå¹³è¡¡äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ä¹‹åï¼Œå…¶ä½™çš„æ•°å­—åˆ†åˆ«ä½äºå¹³è¡¡äºŒå‰æœç´¢æ ‘çš„å·¦å­æ ‘å’Œå³å­æ ‘ä¸­ï¼Œå·¦å­æ ‘å’Œå³å­æ ‘åˆ†åˆ«ä¹Ÿæ˜¯å¹³è¡¡äºŒå‰
    //            æœç´¢æ ‘ï¼Œå› æ­¤å¯ä»¥é€šè¿‡é€’å½’çš„æ–¹å¼åˆ›å»ºå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼›
    //         (5)é€’å½’çš„åŸºå‡†æƒ…å½¢æ˜¯å¹³è¡¡äºŒå‰æœç´¢æ ‘ä¸åŒ…å«ä»»ä½•æ•°å­—ï¼Œæ­¤æ—¶å¹³è¡¡äºŒå‰æœç´¢æ ‘ä¸ºç©ºï¼›
    //         (6)åœ¨ç»™å®šä¸­åºéå†åºåˆ—æ•°ç»„çš„æƒ…å†µä¸‹ï¼Œæ¯ä¸€ä¸ªå­æ ‘ä¸­çš„æ•°å­—åœ¨æ•°ç»„ä¸­ä¸€å®šæ˜¯è¿ç»­çš„ï¼Œå› æ­¤å¯ä»¥é€šè¿‡æ•°ç»„ä¸‹æ ‡èŒƒå›´ç¡®å®šå­æ ‘åŒ…å«çš„æ•°å­—ï¼Œ
    //            ä¸‹æ ‡èŒƒå›´è®°ä¸º[left, right]ï¼Œå¯¹äºæ•´ä¸ªä¸­åºéå†åºåˆ—ï¼Œä¸‹æ ‡èŒƒå›´ä»left=0åˆ°right=nums.length-1ï¼Œå½“left>rightæ—¶ï¼Œ
    //            å¹³è¡¡äºŒå‰æœç´¢æ ‘ä¸ºç©ºã€‚
    //          (7)é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œåˆ™æ ¹èŠ‚ç‚¹çš„ä¸‹æ ‡ä¸ºmid=(left+right)/2
    // æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(logn)  å…¶ä¸­næ˜¯æ•°ç»„çš„é•¿åº¦
    // æ—¶é—´å¤æ‚åº¦è¯´æ˜ï¼šæ¯ä¸ªæ•°å­—åªè®¿é—®ä¸€æ¬¡
    // ç©ºé—´å¤æ‚åº¦è¯´æ˜ï¼šç©ºé—´å¤æ‚åº¦ä¸è€ƒè™‘è¿”å›å€¼ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºé€’å½’æ ˆçš„æ·±åº¦ï¼Œé€’å½’æ ˆçš„æ·±åº¦æ˜¯O(logn)
    // å‚è€ƒèµ„æ–™1ï¼šhttps://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/(å®˜æ–¹è§£)
    // å¤‡æ³¨1ï¼šç”œå§¨ã®åˆ†æï¼šBSTçš„ä¸­åºéå†æ˜¯å‡åºçš„ï¼Œå› æ­¤æœ¬é¢˜ç­‰åŒäºæ ¹æ®ä¸­åºéå†çš„åºåˆ—æ¢å¤äºŒå‰æœç´¢æ ‘ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ä»¥å‡åºåºåˆ—ä¸­çš„ä»»ä¸€ä¸ªå…ƒç´ ä½œä¸º
    //     æ ¹èŠ‚ç‚¹ï¼Œä»¥è¯¥å…ƒç´ å·¦è¾¹çš„å‡åºåºåˆ—æ„å»ºå·¦å­æ ‘ï¼Œä»¥è¯¥å…ƒç´ å³è¾¹çš„å‡åºåºåˆ—æ„å»ºå³å­æ ‘ï¼Œè¿™æ ·å¾—åˆ°çš„æ ‘å°±æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘å•¦ï½ åˆå› ä¸ºæœ¬é¢˜è¦æ±‚
    //     é«˜åº¦å¹³è¡¡ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€‰æ‹©å‡åºåºåˆ—çš„ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹å¥¥ï½
    // å¤‡æ³¨2ï¼šæ³•äºŒå’Œæ³•ä¸‰åœ¨æœ¬è§£æ³•ä»£ç çš„æ³¨é‡Šä¸­
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */
    class Solution {
        public TreeNode sortedArrayToBST(int[] nums) {
            return helper(nums, 0, nums.length - 1);
        }

        /**
         * é€’å½’è°ƒç”¨å‡½æ•°
         * @param nums
         * @param left
         * @param right
         * @return
         */
        public TreeNode helper(int[] nums, int left, int right) {
            if (left > right) {
                return null;
            }
            // æ€»æ˜¯é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹
            int mid = (left + right) / 2;
            // æ³•äºŒï¼šä¸­åºéå†ï¼Œæ€»æ˜¯é€‰æ‹©ä¸­é—´ä½ç½®å³è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹
            // int mid = (left + right + 1) / 2;
            // æ³•ä¸‰ï¼šä¸­åºéå†ï¼Œé€‰æ‹©ä»»æ„ä¸€ä¸ªä¸­é—´ä½ç½®æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹
            // int mid = (left + right + rand.nextInt(2)) / 2;
            TreeNode root = new TreeNode(nums[mid]);
            root.left = helper(nums, left, mid - 1);
            root.right = helper(nums, mid + 1, right);
            return root;
        }
    }
    //leetcode submit region end(Prohibit modification and deletion)

}